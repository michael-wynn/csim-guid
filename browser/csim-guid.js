require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"csim-guid":[function(require,module,exports){
(function (process){
/**
 * Created on 7/28/15. Copyright Michael Wynn - all rights reserved.
 * This work is based on original work cuid by Eric Elliot
 *    New structure: <timestamp(9)><counter(4)><random(in blocks of 4 x configurable # of blocks)>
 *
 */
'use strict';

(function () {
    var isNode = (typeof module === 'object')
        && (typeof process === 'object')
        && (typeof process.versions === 'object')
        && (typeof process.versions.node !== 'undefined');
    var counterSeedOffset = (isNode)? process.pid % 100000 : 0;
    var
        defaultScale = 3,
        scale = defaultScale,
        typicalBlockSize = 4,
        timeStampBlockSize = 9,
        encodingBase = 36,
        blockNumericLimit = Math.pow(encodingBase, typicalBlockSize) - 1,
        counterSeed = counterSeedOffset + Math.floor(randomNumber() / 2),   /* see notes below */
        counterReseedThreshold = Math.floor(blockNumericLimit/2);
    var lastTimestamp,
        counter = counterSeed;

    /* counterSeed: the intention is to start counter at a random value somewhere
     * between 0 and halfway toward the limit, rather than at 0.  This further
     * reduces chance of collision when multiple machines are generating new guid
     * at precisely the same timestamp.  Also, counter will be reseeded each time
     * the timestamp is changed, thus rollover back to 0 is virtually unnecessary:
     * rollover will not trigger unless a machine process generates more than
     * [blockNumericLimit - counterReseedThreshold] times
     * (blockNumericLimit/3, or 559872) within a millisecond! By avoiding
     * rollover, guids generated by same machine process are ensured to be
     * sequential */

    function randomNumber() {
        return Math.random() * blockNumericLimit;
    };

    function pad(num, size) {
        var s = "000000000" + num;
        return s.substr(s.length - size);
    };

    function base36toInt(string) {
        //convert base36 string to integer
        var result = 0;
        var digits = {};
        for (var i = 0; i < 10; i++) {
            digits[String(i)] = i;
        }
        for (i = 0; i < 26; i++) {
            digits[String.fromCharCode(i + 97)] = i + 10;
        }

        for (var i = 0; i < string.length; i++) {
            var num = digits[string.charAt(i)];
            result += Math.pow(36, string.length - i - 1) * num;
        }
        return Math.floor(result);
    };

    function createRandomBlock() {
        return pad(randomNumber().toString(encodingBase), typicalBlockSize);
    };

    function create() {
        var newTimestamp, counterBlock, randomBlock;
        newTimestamp = dateToTimestamp(new Date());

        // counter: if timestamp has changed and counter is too large,
        // then reseed counter to reduce probability of rollover on same timestamp
        if((counter > counterReseedThreshold) && (newTimestamp > lastTimestamp))
            counter = counterSeed;
        counterBlock = pad(counter.toString(encodingBase), typicalBlockSize);
        counter = (counter < blockNumericLimit)? counter + 1 : counterSeed;

        // Grab some more chars from Math.random()
        randomBlock = '';
        for (var i = 1; i <= scale; i++)
            randomBlock = randomBlock + createRandomBlock();

        lastTimestamp = newTimestamp;
        return (newTimestamp + counterBlock + randomBlock);
    };

    function setCounterValueForTestingDoNotUse(value){
        // this is for testing counter roll-over code path; no practical purpose
        counter = value;
    };

    function setScale(value) {
        scale = value || defaultScale;
    };

    function getRandomBlocks() {
        return scale;
    };

    function dateToTimestamp(date){
        return pad((date.getTime()).toString(encodingBase),
            timeStampBlockSize);
    };

    function stampToDate(timeStampBlock){
        return new Date(base36toInt(timeStampBlock));
    }

    function breakdown(guid){
        var timeStampBlock = guid.slice(0, timeStampBlockSize);
        var counterBlock = guid.slice(timeStampBlockSize, timeStampBlockSize + typicalBlockSize);
        var randomBlock = guid.slice(timeStampBlockSize + typicalBlockSize);
        return {
            guid: guid,
            scale: randomBlock.length/4,
            timestamp: timeStampBlock,
            counter: counterBlock,
            random: randomBlock,
            date: stampToDate(timeStampBlock),
            counterDecimal: base36toInt(counterBlock)
        }
    };

    var exportObj = create;
    exportObj.breakdown = breakdown;
    exportObj.setScale =  setScale;
    exportObj.dateToTimestamp = dateToTimestamp;
    exportObj.setCounterValueForTestingDoNotUse = setCounterValueForTestingDoNotUse;

    module.exports = exportObj;

})();
}).call(this,require('_process'))
},{"_process":1}]},{},[]);
